<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Spiro.Angular by SpiroLibraries</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">

    <link rel="stylesheet" href="stylesheets/styles-fixes.css">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <script src="javascripts/main-patched.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">


  </head>
  <body>

      <header>
        <h1>Spiro.Angular</h1>
        <p>AngularJS services for idiomatic access to Restful Objects resources and representations.</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/SpiroLibraries/Spiro.Angular" class="button fork"><strong>View On GitHub</strong></a>
        <!--
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/SpiroLibraries/Spiro.Angular/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/SpiroLibraries/Spiro.Angular/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
        -->
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul>
        </ul>
      </nav>

      <section>
          <h1>
              <a name="spiroangular" class="anchor" href="#spiroangular"><span class="octicon octicon-link"></span></a>Spiro.Angular
          </h1>

          <p>Spiro.Angular is a library for accessing a <a href="http://restfulobjects.org">Restful Objects</a> API
              using the <a href="https://angularjs.org/">AngularJS</a> framework.</p>

          <p>The library provides (currently: aims to provide) a <code>$spiroResource</code> service that acts as a more
              functional replacement for AngularJS' own <a
                      href="https://docs.angularjs.org/api/ngResource/service/$resource">$resource</a>. This transforms
              the Restul Objects representations into a simpler format for easier consumption (eg by <a
                      href="http://mgcrea.github.io/angular-strap/">AngularStrap</a> or <a
                      href="http://angular-ui.github.io/bootstrap/">Angular-UI</a>).

      </section>

      <section>
          <h1>
              <a name="background" class="anchor" href="#background"><span class="octicon octicon-link"></span></a>Background
              ($resource)</h1>

          <p>
              Spiro.Angular tries to provide an API as similar to AngularJS'
              <a target="_blank" href="https://code.angularjs.org/1.2.19/docs/api/ngResource/service/$resource">$resource</a>
              service as
              possible.

          <p>In the simplest case the resource returns a representation of a single &quot;object&quot;</p>
          <ul>
              <li>
                  <p>eg: <code>/customers/:id</code></p>
              </li>
          </ul>
          <p>It also defines five standard actions. Four of these correspond to CRUD:</p>
          <ul>
              <li>
                  <p><code>get()</code> to HTTP GET return a single instance</p>
              </li>
              <li>
                  <p><code>save()</code> to HTTP POST to either create new instance/update existing</p>
                  <ul>
                      <li>
                          update if POST to eg: <code>/customers/:id</code>
                      </li>
                      <li>
                          create if POST to eg: <code>/customers/</code>
                      </li>
                  </ul>
              </li>
              <li>
                  <p><code>remove()</code> or <code>delete()</code> to HTTP DELETE an instance</p>
              </li>
          </ul>
          <p>The fifth standard action relates not to (the representation of) an instance of an object, but instead to a
              &quot;repository&quot; query</p>
          <ul>
              <li>
                  <p><code>query()</code> to HTTP GET return an array of instances (by omitting the <code>:id</code>)
                  </p>
              </li>
          </ul>

          <p>As well as the five standard actions, the developer can also define custom actions. These custom actions
              are what
              enable updates to the object.</p>

          <p>In addition, with all actions it is possible to override the URL, and to provide a
              <code>transformRequest</code> and/or <code>transformResponse</code> function</p>

          <h3>Example of using <code>$resource</code></h3>

          <p>
              Declare a resource with a custom <code>charge</code> action:
          </p>
<pre>
var CreditCard = $resource(
                     '/user/:userId/card/:cardId',
                     {userId:123, cardId:'@id'}, {
                       charge: {method:'POST', params:{charge:true}}
                     });
</pre>

          <p>Query for some matching objects:</p>
<pre>
var cards = CreditCard.query(function() {
// GET: /user/123/card (nb, omits the :id)
// server returns: [ {id:456, number:'1234', name:'Smith'} ];
</pre>

          <p>Update the first instance:</p>
<pre>
var card = cards[0];
card.name = "J. Smith";
card.$save();
// POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}
// server returns: {id:456, number:'1234', name: 'J. Smith'};
</pre>

          <p>Update using the custom action:</p>
<pre>
card.$charge({amount:9.99});

// POST: /user/123/card/456?amount=9.99&charge=true
// server returns:
// {id:456, number:'1234', name:'J. Smith'}
</pre>

          <p>Create a new instance:</p>
<pre>
var newCard = new CreditCard({number:'1234-5678-0987-6543'});
newCard.name = "Mike Smith";
newCard.$save();

// POST: /user/123/card {num:"1234-5678-0987-6543", name:'Mike Smith'}
// server returns:
// {id:789987654561, num:"1234-5678-0987-6543", name: 'Mike Smith'};
</pre>

      </section>

      <section>
          <h1>
              <a name="approach" class="anchor" href="#approach"><span class="octicon octicon-link"></span></a>Approach
          </h1>

          <p>The main API provided by Spiro.Angular is <code>$spiroResource</code>, intended to have a similar API to
              AngularJS' $resource.  It has a similar set of standard actions.  One notable difference is that
              custom actions need not be defined because they are inferred from the underlying Restful Objects
              representations.  The net result for the developer is far less boilerplate, and leveraging of far
              more advanced out-of-the-box capabilities.</p>

          <p>The default representation provided by Spiro.Angular is the property values; this is flattened for easy binding
              into the Angular <code>$scope</code>.</p>
          <p>the Spiro.Angular representation it also includes a special <code>$$ro</code> property.  This provides access to
              other capabilities exposed by the Restful Objects resources.</p>
          <p>Spiro.Angular uses &quot;$$&quot; prefix for various other reserved keys (similar to the way that AngularJS
              uses a &quot;$&quot; prefix for its own reserved keywords and functions).</p>
          <p>For consistency with AngularJS, Spiro.Angular also a single &quot;$&quot; to reference any domain object actions</p>



      </section>

      <section>
        <h1>
<a name="flattened-value-properties" class="anchor" href="#flattened-value-properties"><span class="octicon octicon-link"></span></a>Flattened value properties</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Enable simple bindings of property values into the UI, via <code>$scope</code>.
              </p>
          </div>

            <p>
          Define a resource similarly to the way in which a resource would be defined using $resource:
            </p>
          <h3>Given:</h3>
<pre>
var CreditCard = $spiroResource(
                     "/objects/:domainType/:instanceId",
                     {domainType: 'creditCard', instanceId:'@num'});
</pre>
          <p>
where:
          <ul>
              <li>the first arg is the templated URL</li>
              <li>the second arg is parameter bindings, with parameters pre-bound to literals (shown), functions (not shown) or to placeholders (shown).  This is modelled after the similar args in <code>$resource</code>.</li>
          </ul>
          </p>

          <p>Like <code>$resource</code>, <code>$spiroResource</code> supports HTTP GET with the <code>get()</code> standard action.</p>

          <h3>When:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>

          <h3>Then:</h3>
          <p>the result of a get() is a transformed result which flattens for easy binding to <code>$scope</code>:
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith"
}
</pre>

            <p>
                Hidden properties should not be included.  (This is true for collections and actions, below, also).
            </p>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">Reference properties</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              The already-spiked "response transformer" does the flattening.
          </p>

      </section>

      <section>
        <h1>
<a name="ro-access" class="anchor" href="#ro-access"><span class="octicon octicon-link"></span></a>$$ro access</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Support arbitrary more sophisticated use cases through the RO representations..
              </p>
          </div>

          <p>
              Spiro appends an additional property <code>$$ro</code>, which holds (reformatted) additional
              properties about the object obtained from the underlying Restful Objects representations.  In particular,
              it provides the <code>$$ro.$$href</code> to access the RO "Object" representation and
              <code>$$ro.$$title</code> to obtain the object's (human-friendly) title.
          </p>

          <h3>When:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  $$ro: {
    $$href:
      "http://localhost:8080/rest/objects/creditCard/1234-5678-9012-3456",
    $$title: "1234-5678-9012-3456 (Mike Smith)"
  }
}
</pre>

        <h3>Discussion</h3>
        <p>
            The title of the CreditCard can then be easily obtained:
        </p>
<pre>
card.$$ro.$$title
</pre>

          <!--
          <h3>See also</h3>
          <ul>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
          </p>
          -->

      </section>

      <section>
        <h1>
<a name="property-metadata" class="anchor" href="#property-metadata"><span class="octicon octicon-link"></span></a>Property Metadata</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Provide hints to indicate the datatypes, also other metadata information.   
              </p>
          </div>

          <p>
              The idea here is to enable more sophisticated UI widgets to consume the data (possibly even completely
              generic ultimately).  It also establishes some structure on which subsequent features build.
          </p>

          <h3>When:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  $$ro: {
    ...,
    num: {
      memberType: "property",
      dataType: "string",
      length: 19,
      friendlyName: "Credit card number",
      detail: "http://localhost:8080/rest/creditCard/1234-5678-9012-3456/property/num"
    },
    name: {
      memberType: "property",
      dataType: "string",
      length: 50,
      friendlyName: "Name",
      detail: "http://localhost:8080/rest/creditCard/1234-5678-9012-3456/property/name"
    },
    ...
  }
}
</pre>

          <!--
          <h3>See also</h3>
          <ul>
            TODO - do we also have use cases that surface the metadata for collections, actions and action parameters and also the object types themselves?
          </ul>

          <h3>Implementation Notes</h3>
          <p>
          </p>
            -->

      </section>

      <section>
        <h1>
<a name="lazy-resolving" class="anchor" href="#lazy-resolving"><span class="octicon octicon-link"></span></a>Lazy Resolving</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Determination and management of resolving of the representation
              </p>
          </div>

          <p>
              Angular's <code>$resource</code> is intended to return a representation that can be bound immediately
              into the scope.  Then, when the (async) request completes, $resource updates the representation; any UI
              widgets are automatically updated.
          </p>
          <p>
              Angular also allows indicates whether this has happened using a "resolved" property.
          </p>
          <p>
              Following <code>$resource</code>'s lead, the <code>$$ro.$$resolved</code> property indicates if the
              representation has been resolved yet, and <code>$$ro.$$promise</code> provides access to the pending
              promise, eg to register additional completion callbacks.
          </p>

          <h3>When:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <h3>Then initially returns:</h3>
<pre>
{
  $$ro: {
    ...,
    $$resolved: false,
    $$promise: ...
  }
}
</pre>

          <h3>And when:</h3>
        <p>
            ... the underlying async call has completed ...
        </p>
          <h3>Then:</h3>
          <p>the map is dynamically updated:</p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  $$ro: {
    $$resolved: true,
    $$promise: ...,
    $$href: "http://localhost:8080/rest/objects/creditCard/1234-5678-9012-3456",
    $$title: "1234-5678-9012-3456 (Mike Smith)"
  }
}
</pre>

          <h3>Discussion</h3>
          <p>
              The client can therefore set up a watch on <code>{{$scope.$$ro.$$resolved}}</code> and use as a
              mechanism to be triggered when complete successfully.  One possibility is to use as the value of an
              <code>ng-show</code> directive:
          </p>

<pre>
&lt;div ng-show=&quot;$$ro.$$resolved&quot;&gt;
    &lt;label&gt;{{name}}&lt;/label&gt;
&lt;/div&gt;
</pre>

          <p>
              Or, the client can add callbacks:
          </p>
<pre>
$$scope.$$ro.$$promise.then(function() { ... })
</pre>

      </section>

      <section>
        <h1>
<a name="reference-properties" class="anchor" href="#reference-properties"><span class="octicon octicon-link"></span></a>Reference Properties</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Enable rendering of references to other representations.
              </p>
          </div>

          <p>
              As well as simple scalar value properties, the object representation should also include (scalar)
              references to (the resources of) related objects.
          </p>

          <h3>When:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  customer: {
    $$href: "http://localhost:8080/rest/customers/1234567",
    $$title: "#1234567: Mr. Michael Smith"
  },
  $$ro: {
    ...
    customer: {
      memberType: "property",
      dataType: "customer",
      friendlyName: "Customer",
      detail: "http://localhost:8080/rest/creditCard/1234-5678-9012-3456/property/customer"
    }
  }
}
</pre>

          <h3>Discussion</h3>
          <p>
              Here <code>customer</code> is a map containing an href (<code>$$href</code>) to another object.  The
              title (<code>$$title</code>) is also provided so client can render the link with a human-readable
              description.
          </p>
          <p>
              In the metadata, the <code>$$ro.customer.dataType</code> holds the (compile-time) domain type of the
              referenced resource.
          </p>

          <h3>See also</h3>
          <ul>
              <li><a href="#flattened-value-properties">Value properties</a></li>
          </ul>


      </section>

      <section>
        <h1>
<a name="hateoas-support" class="anchor" href="#hateoas-support"><span class="octicon octicon-link"></span></a>HATEOAS Support</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Support Hateoas traversal (eg to customer.$$href in previous iteration, or to collections, or to results of action)
              </p>
          </div>

          <p>
              <code>$spiroResource</code> defines <code>getUrl()</code> as an additional "standard" action.  This acts
              somewhat like <code>get()</code>, but accepts a URL instead.
          </p>

          <h3>When:</h3>
<pre>
var card = CreditCard.getUrl(
           "http://localhost:8080/rest/objects/creditcard/1234-5678-9012-3456")
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  customer: { ... }
  $$ro: { ... }
}
</pre>

      </section>

      <section>
        <h1>
<a name="collections-as-lists" class="anchor" href="#collections-as-lists"><span class="octicon octicon-link"></span></a>Collections as lists</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Enable rendering of collections in lists.
              </p>
          </div>

          <p>
              Extend the representation to include collections, eagerly resolved and showing titles (so can be rendered
              in a list)
          </p>

          <h3>When:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  recentPurchases: [
    { $$href: "http://localhost:8080/rest/objects/purchase/123456701"
      $$title: "Beverages from Starbuck, $4.95"
    },
    { $$href: "http://localhost:8080/rest/objects/purchase/123456702"
      $$title: ...
    },
    { $$href: "http://localhost:8080/rest/objects/purchase/123456703"
      $$title: ...
    },
  ],
  $$ro: {
    ...
    recentPurchases: {
      memberType: "collection",
      dataType: "customer",
      friendlyName: "Recent Purchases",
      resolved: true,
      resolveStyle: "list",
      ...
    }
  }
}
</pre>

          <h3>Discussion</h3>
          <p>
              In the metadata:
          </p>
          <ul>
              <li><code>$$ro.recentPurchases.resolved</code> - indicates whether the collection has been resolved.</li>
              <li><code>$$ro.recentPurchases.resolveStyle</code> - indicates how the collection was resolved</li>
              <li><code>$$ro.recentPurchases.dataType</code> - holds the (compile-time) domainType of the referenced resources</li>
          </ul>

          <h3>See also</h3>
          <ul>
              <li><a href="#collections-as-tables">Collections as Tables</a></li>
              <li><a href="#lazily-rendered-collections">Lazy resolving of collections</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              To efficiently implement will require RO v1.2.
          </p>

      </section>

      <section>
        <h1>
<a name="collections-as-tables" class="anchor" href="#collections-as-tables"><span class="octicon octicon-link"></span></a>Collections as tables</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Enable rendering of collections in tables.
              </p>
          </div>

          <p>
              Extend the eagerly resolved representation of collections to include other properties of those referenced
              objects (so can be rendered in a table)
          </p>

          <h3>When:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  recentPurchases: [
    { $$href: "http://localhost:8080/rest/objects/purchase/123456701",
      $$title: "Beverages from Starbuck, $4.95",
      description: "Beverages",
      vendor: "Starbucks",
      date: "2014-07-10",
      amount: 4.95
    },
    { $$href: "http://localhost:8080/rest/objects/purchase/123456702",
      $$title: ...,
      description: ...,
      vendor: ...,
      date: ...,
      amount: ...
    },
    { $$href: "http://localhost:8080/rest/objects/purchase/123456703",
      $$title: ...,
      description: ...,
      vendor: ...,
      date: ...,
      amount: ...
    },
  ],
  $$ro: {
    ...
    recentPurchases: {
      ...
      resolved: true,
      resolveStyle: "table",
      ...
    }
  }
}
</pre>

          <h3>Discussion</h3>
          <p>
              Whether a <a href="#collections-as-lists">list representation</a> or the full table representation is
              returned is in the first event determined by the server.  However, the client could also
              <a href="#lazily-rendered-collections">provide hints</a> influencing this behaviour.
          </p>

          <h3>See also</h3>
          <ul>
              <li><a href="#collections-as-lists">Collections as Lists</a></li>
              <li><a href="#lazily-rendered-collections">Lazy resolving of collections</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              To efficiently implement will require RO v1.2.
          </p>

      </section>

      <section>
        <h1>
            <a name="lazily-rendered-collections" class="anchor"
               href="#lazily-rendered-collections">
                <span class="octicon octicon-link"></span>
            </a>Lazily rendered collections</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                    Render placeholders for collections that are less likely to be required (not eagerly rendered).
              </p>
          </div>

          <p>
              Rather than eagerly resolving collections, the server might return only a placeholder for the collection;
              the client could render the collection in a &quot;collapsed&quot; form.
          </p>

          <h3>When:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  recentPurchases: null,
  $$ro: {
    ...
    recentPurchases: {
      ...
      resolved: false,
      resolveStyle: null,
      ...
    }
}
</pre>

          <h3>Discussion</h3>
          <p>
              However, the client must have the capability to request that the collection be resolved 
              (&quot;expanded&quot;); this is discussed in
              <a href="#resolve-collection">Resolve Collection</a>.
          </p>

          <h3>See also</h3>
          <ul>
              <li><a href="#resolve-collection">Resolve Collection</a>.</li>
          </ul>
      </section>

      <section>
      <h1>
          <a name="resolve-collection" class="anchor" href="#resolve-collection"><span
                  class="octicon octicon-link"></span></a>Resolve Collection</h1>

          <div class="use-case">
          <h3>Use case</h3>
          <p>
              Resolve collections that were previously lazily rendered.
          </p>
      </div>

      <p>
          For collections that the server has rendered lazily (with a placeholder), a mechanism is required so that
          the client can request that the collection be resolved.  This is done by Spiro setting up a watch on the
          appropriate part of the returned representation acting as a flag/toggle, such that it can do the resolve if
          requested.
      </p>

      <h3>Given:</h3>
          <p>A representation of a lazily resolved collection:</p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  recentPurchases: null,
  $$ro: {
    ...
    recentPurchases: {
      ...
      resolved: false,
      resolveStyle: null,
      ...
    }
}
</pre>
        <p>... with Spiro setting up its own watch on the collection
            (eg <code>{{$scope.recentPurchases.resolveStyle}}</code>) to respond to a resolve request.</p>
          <h3>When:</h3>
<pre>
card.$$ro.recentPurchases.resolveStyle = "list"
</pre>
          <p>or similarly:</p>
<pre>
card.$$ro.recentPurchases.resolveStyle = "table"
</pre>

      <h3>Then:</h3>
      <p>Spiro will then resolve the collection using either of two styles, <a href="#collections-as-lists">list</a> or <a href="#collections-as-tables">table</a>.
          It will also update the representation to include a promise:
      </p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  recentPurchases: null,
  $$ro: {
    ...
    recentPurchases: {
      ...
      resolved: false,
      resolveStyle: "table",
      promise: ...
      ...
    }
}
</pre>

      <h3>Discussion</h3>
      <p>
          The client can then also setup their own additional callbacks on this promise:
      </p>
<pre>
card.$$ro.recentPurchases.promise.then(function(){ ... })
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#lazily-rendered-collections">Lazily rendered collections</a></li>
          </ul>

          <h3>Implementation Notes</h3>
              <p>As noted above, this feature requires Spiro setting up its own watch on the collection
              (eg <code>{{$scope.recentPurchases.resolveStyle}}</code>) to respond to a resolve request.</p>
      </section>

      <section>
        <h1>
            <a name="actions" class="anchor" href="#actions"><span class="octicon octicon-link"></span></a>Actions</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Enable domain object actions to be invoked.
              </p>
          </div>

          <p>
              Whereas <code>$resource</code> requires custom 'actions' to be explicitly mapped, Spiro can
              automatically map any domain object actions provided by RO as actions on the <code>$spiroResource</code>
              instance.  Following <code>$resource</code>'s convention, these actions all have a
              &quot;<code>$</code>&quot; prefix.
          </p>

          <h3>Given:</h3>
          <p>eg, if CreditCard has an <code>expireOn(date)</code> action, then the map is basically:</p>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <p>returning:</p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $expireOn: ... // a Spiro provided function that knows how to invoke the action
  $$ro: {
    ...
    $expireOn: {
      memberType: action,
      friendlyName: "Expire on",
      parameters: {
        date: {
          dataType: date,
          friendlyName: "Date"
        }
      }
      detail: "http://localhost:8080/rest/creditCard/1234-5678-9012-3456/action/expireOn"
    }
  }
}
</pre>
          <h3>When:</h3>
<pre>
card.$expireOn({date: "2014-07-15"})
</pre>
          <h3>Then:</h3>
          <p>Spiro will first copy the arguments into <code>$$ro</code>:</p>
<pre>
{
  ...
  $$ro: {
    ...
    $expireOn: {
      parameters: {
        date: {
          argument: "2014-07-15"
        }
      }
      ...
    }
  }
}
</pre>
        <p>and then immediately execute the action.</p>

          <h3>Discussion</h3>
          <p>
              After the action is invoked, Spiro must automatically refresh the entire object representation because
              arbitrary properties may have changed.  In essence, this is an &quot;HTTP redirect (to GET) after
              POST&quot;:
          </p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  ... // other properties updated if changed by action
  ...
}
</pre>

      </section>

      <section>
        <h1>
<a name="action-results" class="anchor" href="#action-results"><span class="octicon octicon-link"></span></a>Action results</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Make the results of an action available to the client (HATEOAS support)
              </p>
          </div>

          <p>
              Angular's <code>$resource</code>'s actions always return an updated representation of the same object;
              there is no real HATEOAS support.  RO in contrast hardly ever returns the same representation.
          </p>
          <p>
              To make <code>$spiroResource</code> have the same &quot;feel&quot; as <code>$resource</code>, it should always return the same representation.  But to enable HATEOAS, the result of the most recent action should be made available under "$$ro" property.  The app can then read it and follow if it wishes.
          </p>

          <h3>Given an action that returns a list</h3>
          <p>
              Assume there is a <code>$findPurchases</code> action to find items that have been purchased using the
              credit card in a particular timespan
          </p>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <p>
            returning:
          </p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $findPurchases: ...,
  $$ro: {
    $findPurchases: {
      memberType: "action",
      friendlyName: "Find purchases",
      parameters: {
        from: {
          dataType: date,
          friendlyName: "From"
        },
        to: {
          dataType: date,
          friendlyName: "To"
        }
      }
    }
  }
}
</pre>
          <h3>When:</h3>
<pre>
card.$findPurchases({from: "2014-07-01", to: null})
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $findPurchases: ...,
  $$ro: {
    ...
    $findPurchases: {
      ...
      result: [
        { $$href: "http://localhost:8080/rest/objects/purchase/123456701",
          $$title: "Beverages from Starbuck, $4.95"
        },
        { $$href: "http://localhost:8080/rest/objects/purchase/123456702",
          $$title: ...
        },
        { $$href: "http://localhost:8080/rest/objects/purchase/123456703",
          $$title: ...
        },
        { $$href: "http://localhost:8080/rest/objects/purchase/123456704",
          $$title: ...
        }
      ],
      ...
    }
  }
}
</pre>
          <p>
              where <code>$$ro.$findPurchases.result</code> holds the result of the action.
          </p>

          <h3>Given an action that returns an object</h3>
          <p>
                eg assume there is a $mostRecentPurchase action to finds the most recently purchased item:
          </p>

        <h3>When:</h3>
<pre>
card.$mostRecentPurchase()
</pre>
        <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $mostRecentPurchase: ...,
  $$ro: {
    ...
    $mostRecentPurchase: {
      ...
      result: {
        $href: "http://localhost:8080/rest/objects/purchase/123456701",
        $title: "Beverages from Starbuck, $4.95"
      }
    }
  }
}
</pre>
        <p>
            So, if the action returns a single object, then the <code>$$ro.$findPurchases.result</code> holds a
            representation of that object.
          </p>


        <h3>Given an action that returns a scalar</h3>
        <p>
            eg assume there is a <code>$countPurchases</code> action to count the number of purchased items in a date range:
        </p>
        <h3>When:</h3>
<pre>
card.$countPurchases()
</pre>
        <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $countPurchases: ...,
  $$ro: {
    ...
    $countPurchases: {
      ...
      result: 9
    }
  }
}
</pre>

        <h3>Given an action that returns void:</h3>
        <p>
            eg the <code>$expireOn</code> action
        </p>
        <h3>When:</h3>
<pre>
card.$expireOn({date: "2014-07-15"})
</pre>
        <h3>Then:</h3>
        <p>
            The <code>result</code> property is removed (if present).
        </p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $expire: ...,
  $$ro: {
    ...
    $expireOn: {
      ... // no "result" property
    }
  }
}
</pre>

        <h3>Discussion</h3>
          <p>
              The intention is for the client to either respond immediately to a new value under
              <code>$$ro.$findPurchases.result</code>, or just ignore it. Anything previously stored at
              <code>$$ro.$xxx.result</code> will be overwritten.
          </p>

      </section>

      <section>
        <h1>
<a name="automatically-updated-properties" class="anchor" href="#automatically-updated-properties"><span class="octicon octicon-link"></span></a>Automatically updated properties</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Updating the values bound to the scope should automatically update the server via the RO REST API
              </p>
          </div>

          <p>
              Whereas <code>$resource</code> requires an explicit call to <code>$save</code> method, with Spiro we
              can automatically update properties through a directive, <code>spiro-update</code>.
          </p>

          <h3>Directive on a single property:</h3>
          <p>
              In the simple case this directive could be applied to the input field for a single property:
          </p>
<pre>
&lt;input ng-model=&quot;name&quot; spiro-update&gt;${name}&lt;/input&gt;
</pre>
          <h3>Directive for a number of properties in a form:</h3>
          <p>
              This directive could also be inherited from a parent div or form:
          </p>
<pre>
&lt;div spiro-update&gt;
  &lt;input ng-model=&quot;name&quot;&gt;${name}&lt;/input&gt;
  &lt;input ng-model=&quot;address&quot;&gt;${address}&lt;/input&gt;
&lt;/div&gt;
</pre>

          <h3>Implementation Notes</h3>
          <p>
              In both cases the directive would watch for changes to the scope <code>{{$scope.name}}</code> using the
              <code>$scope.$watch</code> API.  If notified of a change then Spiro will automatically post the change
              to the corresponding RO resource.
          </p>

          <p>
              A slight issue here is that if the property that <a href="#property-choices-conditional">has</a>
              <a href="#property-auto-complete-conditional">dependents</a> on it, then the current value of those
              dependents may change.  Updating those dependent properties is a server-side responsibility, but Spiro
              will automatically refresh the entire object representation whenever a property is updated to ensure it
              is sync.  In essence, this is an "HTTP redirect (to GET) after POST"
          </p>

      </section>

      <section>
        <h1>
<a name="updating-view-models" class="anchor" href="#updating-view-models"><span class="octicon octicon-link"></span></a>Updating view models</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Support editable view models (Isis' implementation)
              </p>
          </div>

          <p>
              Normally updating a property will mutate that object and return a representation of that object; but in
              theory (and in Isis' view model implementation) the target object could be immutable and instead return
              the URL of a new modified target object in its stead.  Thus, invoking a property modification could
              result in a new resource to fetch.  This is captured in <code>$$ro.property.result</code>, same as
              for actions.
          </p>

          <h3>Given:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <p>
          returning:
          </p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $$ro: { ... }
}
</pre>
          <h3>When:</h3>
<pre>
card.name = "Joe Smith"
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Joe Smith",
  ...
  $$ro: {
    ...
    name: {
      result: {
        $$href: "http://localhost:8080/rest/objects/cards/1234-5678-9012-3456",
        $$title: "1234-5678-9012-3456 (Joe Smith)"
      }
    }
  }
}
</pre>

          <h3>Discussion</h3>
          <p>
              In this particular example the object itself has been mutated - probably the backing object is an entity.
              However, it might not in general; the <code>$$ro.name.result.$$href</code> does not necessarily always
              equal <code>$$ro.$$href</code>.
          </p>
          <p>
              As for actions, the intention is for the client to either respond immediately to a new value under
              <code>$$ro.xxx.result.$$href</code>, or ignore it. Therefore, any previously stored will be overwritten.
          </p>

          <!--
          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>
          -->

      </section>

      <section>
        <h1>
<a name="custom-finders" class="anchor" href="#custom-finders"><span class="octicon octicon-link"></span></a>Custom finders</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Provide alternative mechanisms for retrieving representations
              </p>
          </div>

          <p>
              Similar to the way that <code>$resource</code> allows custom actions to be defined, so does
              <code>$spiroResource</code>.
          </p>
          <p>
              One difference is that whereas <code>$resource</code> actions are either Javascript
              &apos;instance&apos; methods or &apos;class&apos; methods, with Spiro the instance actions of the
              domain object are automatically surfaced.  Therefore <code>$spiroResource</code>'s custom actions
              are intended only to &quot;attach&quot; relevant finder or factory actions of domain services, and these
              always mapped as &apos;class&apos; actions.  For example, if a domain entity <code>Customer</code> has
              a corresponding domain service <code>Customers</code>, then the service's <code>findById()</code> and
              <code>newCustomer</code> can be mapped as class actions on the Javascript <code>Customer</code> resource.
          </p>

          <h3>Given:</h3>
          <p>
              a domain service <code>CreditCards</code> with actions <code>findByName()</code> and
              <code>findExpired()</code>
          </p>
          <h3>When:</h3>
          <p>
              the Javascript <code>CreditCard</code> is defined:
          </p>
<pre>
var CreditCard = $spiroResource(
                     "/objects/creditCard/:instanceId",
                     {instanceId:'@num'},
                     {
                       findByName: "/services/creditCards/action/findByName/invoke",
                       findExpired: "/services/creditCards/action/findExpired/invoke",
                     });
</pre>
          <h3>Then:</h3>
<pre>
var cards = CreditCard.findByName({name: "Jones"})
</pre>

          <!--
          <h3>Discussion</h3>
          <p>
              TODO
          </p>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>
          -->
      </section>

      <section>
        <h1>
<a name="disabled-members" class="anchor" href="#disabled-members"><span class="octicon octicon-link"></span></a>Disabled members</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Some members may become disabled or enabled, and so we need a way to expose this fact easily so that
                the UI can reflect the fact.
              </p>
          </div>

          <p>
              Rather than have Spiro attempt to manipulate the DOM, we expose the information under <code>$$ro</code>.
              The UI component can then set up a watch expression on its scope.
          </p>

          <h3>Given:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <p>
              returning:
          </p>
<pre>
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  customer: { ... },
  recentPurchases: [ ... ],
  $expireOn: ...,
  $findPurchases: ...,
  ...
  $$ro: {
    num: {
      ...
      disabled: true,
      disabledReason: "Not modifiable."
    },
    name: {
      ...
      disabled: false
    },
    customer: {
      ...
      disabled: true,
      disabledReason: "Use 'update customer' action to alter."
    }
    recentPurchases: {
      ...
      disabled: true,
      disabledReason: "Read-only (derived) collection."
    }
    $expireOn: {
      ...
      disabled: true,
      disabledReason: "This card has already been set to expire."
    }
    $findPurchases: {
      ...
      disabled: false
    }
    ...
  }
}
</pre>

          <h3>When:</h3>
          <p>
          Set up a watch expression, eg:
          </p>
<pre>
&lt;input ng-model=&quot;name&quot; disabled=&quot;{{scope.$$ro.name.disabled}}&quot;&gt;{{name}}&lt;/input&gt;
</pre>

          <p>
          or more simply:
          </p>
<pre>
&lt;input ng-model=&quot;name&quot; ng-disabled=&quot;$$ro.name.disabled&quot;&gt;{{name}}&lt;/input&gt;
</pre>

          <h3>Then:</h3>
          <p>
              the input field will be disabled whenever the representation indicates that the property is also disabled.
          </p>

          <!--
          <h3>Discussion</h3>
          <p>
          </p>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
          </p>
          -->
      </section>

      <section>
        <h1>
<a name="invalid-properties" class="anchor" href="#invalid-properties"><span class="octicon octicon-link"></span></a>Invalid properties</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Validate changes to properties before submitting, and feed back reason if invalid.
              </p>
          </div>

          <p>
              As for <a href="#disabled-members">disabling properties</a>, a watch expression under <code>$$ro</code> can also be used to validate
              changes to properties.
          </p>

          <h3>Given:</h3>
<pre>
var card = CreditCard.get({num: "1234-5678-9012-3456"})
</pre>
          <p>
              returning:
          </p>
<pre>
{
  num: "1234-5678-9012-3456",
  cardHolder: "Mike Smith",
  ...
  $$ro: {
    ...
    name: {
      ...
      disabled: false
    },
    ...
  }
}
</pre>
          <p>
              and also have set up an appropriate watch expression on <code>{{scope.$$ro.name.invalid}}</code>, for
              example using a custom directive:
          </p>
<pre>
app.directive('spiroValidate', function() {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, elem, attr, ctrl) {
            scope.$watch('$$ro' + ctrl.name + '.invalid', function(value) {}
                ctrl.$setValidity('spiroValidate', value);
            });
        }
    };
});
</pre>
            <p>
                with corresponding markup:
            </p>
<pre>
&lt;form name=&quot;myForm&quot; ng-submit=&quot;doSomething()&quot;&gt;
    &lt;input type=&quot;text&quot;
           ng-model=&quot;cardHolder&quot; name=&quot;cardHolder&quot;
           spiro-validate /&gt;
    &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.cardHolder.$error.spiroValidate&quot;&gt;$$ro.cardHolder.invalidReason&lt;/span&gt;
    &lt;button type=&quot;submit&quot; ng-disabled=&quot;myForm.$invalid&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>
          <h3>When:</h3>
<pre>
card.name="Mike_Smith!"
</pre>
          <h3>Then:</h3>
<pre>
{
  num: "1234-5678-9012-3456",
  cardHolder: "Mike Smith",
  ...
  $$ro: {
    ...
    cardHolder: {
      ...
      invalid: true,
      invalidReason: "Name can contain only alphabetic characters, space or hyphen '-'."
    }
    $$href: ...,
    $$title: ...
  }
}
</pre>
          <h3>Discussion</h3>
          <p>
              The directive shown above is only responsible for watching the changes that Spiro makes under <code>$$ro</code>
              and reflecting them back into the UI.  In addition, Spiro will also have set its own watch on the original
              value (<code>scope.cardHolder</code>) in order to make an HTTP call to the corresponding RO resource
              when the value changes; see <a href="#automatically-updated-properties">here</a>.
          </p>

          <h3>See also</h3>
          <ul>
              <li><a href="#automatically-updated-properties">Automatically updated properties</a></li>
          </ul>

          <!--
          <h3>Implementation Notes</h3>
          <p>
          </p>
          -->

      </section>

      <section>
        <h1>
<a name="invalid-action-parameter" class="anchor" href="#invalid-action-parameter"><span class="octicon octicon-link"></span></a>Invalid action parameter</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Validate individual action parameter, and feedback if invalid.
              </p>
          </div>

          <p>
              UP TO HERE FOR REFORMATTING/TIDYING UP...
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>

Again, approach is to use a watch expression under $$ro.

eg:
card.$expireOn({date: "2013-01-01"})

returns:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $expireOn: ...,
  ...
  $$ro: {
    ...
    $expireOn: {
      parameters: {
        date: {
          argument: "2013-01-01",   // automatically updated by Spiro on submit, see iteration #10
          invalid: true,
          invalidReason: "The expiry date must be in the future"
        }
      }
      invalid: true
    }
  }
}

then set up a watch expression on {{$scope.$$ro.$expireOn.parameters.date.invalid}}.

In addition, the $$ro.$expireOn.invalid is a convenience that allows a watch expression to be used to disable the OK button (meaning there is at least one validation error for one of the parameter arguments).
</pre>

      </section>

      <section>
        <h1>
<a name="invalid-action-parameters" class="anchor" href="#invalid-action-parameters"><span class="octicon octicon-link"></span></a>Invalid action parameters</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Validate multiple action parameters, and feedback if invalid.
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


Again, approach is to use a watch expression under $$ro.

eg:
card.$findPurchases({from: "2014-07-01", to: "2014-06-01"})

returns:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $findPurchases: ...,
  ...
  $$ro: {
    ...
    $findPurchases: {
      parameters: { ... }
      invalid: true,
      invalidReason: "The 'to' date must come after the 'from' date"
    }
  }
}

then set up a watch expression on {{scope.$$ro.$expireOn.invalid}}.  Unlike the previous use case, here it is the combination of arguments that are invalid, so the 'invalidReason' is at the same level as the 'invalid' property.
</pre>

      </section>

      <section>
        <h1>
<a name="property-choices" class="anchor" href="#property-choices"><span class="octicon octicon-link"></span></a>Property choices</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Provide list of choices for a property
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


Expose the choices under $$ro property.

Suppose 'issuedBy' is a simple value property,

eg:
var card = CreditCard.get({num: "1234-5678-9012-3456"})

returns:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  issuedBy: "Amex",
  ...
  $$ro: {
    ...
    issuedBy: {
      ...
      choices: [ "Visa", "Mastercard", "Amex" ]
    }
  }
}

~~
Suppose instead 'issuedBy' is a reference property, then:

returns:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  issuedBy: "Amex",
  ...
  $$ro: {
    ...
    issuedBy: {
      choices: [ 
        { $href: "http://localhost:8080/rest/objects/issuer/visa",
          $title: "Visa" }, 
        { $href: "http://localhost:8080/rest/objects/issuer/mastercard",
          $title: "Mastercard" }, 
        { $href: "http://localhost:8080/rest/objects/issuer/amex",
          $title: "Amex" },
      ]
    }
  }
}
</pre>

      </section>

      <section>
        <h1>
<a name="property-auto-complete" class="anchor" href="#property-auto-complete"><span class="octicon octicon-link"></span></a>Property auto-complete</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Start entering values and provide matching options.  NB: this concept seems to be called "typeahead" in AngularJS.
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


Spiro sets up a watch on an "proposed" property under $$ro and populates choices with corresponding matches.  The client can set up its own watch on the resultant choices.

eg if "clearingBank" is a reference property:

given:
var card = CreditCard.get({num: "1234-5678-9012-3456"})
returning:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  clearingBank: {
    $href: "http://localhost:8080/rest/objects/bank/barclays",
    $title: "Barclays"
  }
  $$ro: {
    ...
    clearingBank: {
      ...
      proposed: null,
      choices: [ ]
    }
  }
}

when
card.$$ro.clearingBank.proposed = "San"

then:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  clearingBank: {
    $href: "http://localhost:8080/rest/objects/bank/barclays",
    $title: "Barclays"
  }
  $$ro: {
    ...
    clearingBank: {
      ...
      proposed: "San",
      choices: [
        {
          $href: "http://localhost:8080/rest/objects/bank/santander",
          $title: "Santander"
        },
        {
          $href: "http://localhost:8080/rest/objects/bank/santa-monica",
          $title: "Santa Monica Bank"
        },
        {
          $href: "http://localhost:8080/rest/objects/bank/san-jose",
          $title: "San Jose Banking Corp"
        },
        ...
      ]
    }
  }
}
</pre>

      </section>

      <section>
        <h1>
<a name="property-choices-conditional" class="anchor" href="#property-choices-conditional"><span class="octicon octicon-link"></span></a>Property choices (conditional)</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Select choice from list of available choices, themselves dependent on other property choices.
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


The API is the same as for unconditional property choices (iteration #19, above) except that Spiro automatically uses the values of the other properties when submitting to the property prompt resource.

eg Suppose CreditCard can be categorized using 'category' and 'subcategory':

given:
var card = CreditCard.get({num: "1234-5678-9012-3456"})
returning:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  category: "CAT-1",
  subcategory: "SUBCAT-1-a",
  ...
  $$ro: {
    ...
    category: {
      ...
      choices: [ "CAT-1", "CAT-2", "CAT-3" ]
    },
    subcategory: {
      ...
      choices: [ "SUBCAT-1-a", "SUBCAT-1-b", "SUBCAT-1-c" ]
    }
  }
}

when:
card.category = "CAT-2"

then:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  category: "CAT-2",
  subcategory: "SUBCAT-2-a",
  ...
  $$ro: {
    ...
    category: {
      ...
      choices: [ "CAT-1", "CAT-2", "CAT-3" ]
    },
    subcategory: {
      ...
      choices: [ "SUBCAT-2-a", "SUBCAT-2-b", "SUBCAT-2-c" ]
    }
  }
}

Note that the subcategory property also changes as well as the list of choices for subcategory.  Computing these values is a server-side responsibility, but Spiro must automatically refresh the entire object representation whenever a property is updated.  In essence, this is an "HTTP redirect (to GET) after POST"
</pre>

      </section>

      <section>
        <h1>
<a name="property-auto-complete-conditional" class="anchor" href="#property-auto-complete-conditional"><span class="octicon octicon-link"></span></a>Property auto-complete (conditional)</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Start entering values and provide matching options, dependent on other property choices.
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


The API is the same as unconditional auto-complete (iteration #20, above) except that Spiro automatically uses the values of the other properties when submitting to the property prompt resource.
</pre>

      </section>

      <section>
        <h1>
<a name="action-param-defaults" class="anchor" href="#action-param-defaults"><span class="octicon octicon-link"></span></a>Action param defaults</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Render a dialog prompt with action arguments set to default values
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


Spiro watches a property under $$ro to allow the developer to request the default argument values to be requested (similar to the way that a resolve can be requested on a collection).

Suppose the 'expireOn(date)' action provides a default for its date parameter.

given:
var card = CreditCard.get({num: "1234-5678-9012-3456"})

and:
card.$$ro.$recategorize.parameters.category.argument="CAT-2"

returning:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $expireOn: ...
  ...
  $$ro: {
    ...
    $expireOn: {
      ...
      parameters: {
        date: {
          argument: null,
          ...
        }
      }
      prompt: false,
    }
  }
}

Spiro watches $$ro.$expireOn.prompt.

when:
card.$$ro.$expireOn.prompt = true

then:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  ...
  $expireOn: ...
  ...
  $$ro: {
    ...
    $expireOn: {
      ...
      parameters: {
        date: {
          argument: "2014-07-15",
          ...
        }
      }
      prompt: true,
    }
  }
}

causes Spiro to request and populate the default argument for each of the parameters of the action.
</pre>

      </section>

      <section>
        <h1>
<a name="action-param-choices" class="anchor" href="#action-param-choices"><span class="octicon octicon-link"></span></a>Action param choices</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Select choice from list of available choices for an action parameter
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


Suppose 'changeIssuedByOn(issuedBy, date)' is an action.  Spiro exposes list of choices under $$ro when prompted.

eg:
var card = CreditCard.get({num: "1234-5678-9012-3456"})

initially returns:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  issuedBy: "Amex",
  $changeIssuedByOn: ...
  ...
  $$ro: {
    ...
    issuedBy: { ... },
    $changeIssuedByOn: {
      ...
      parameters: {
        issuedBy: {
          ...
          choices: null
        },
        date: { ... }
      },
      prompt: false
    }
  }
}

The "choices" property is present to indicate that choices are available for this parameter, but is set to null because they won't be computed until prompt is requested.

when:
card.$$ro.$changedIssuedByOn.prompt = true

then :
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  issuedBy: "Amex",
  $changeIssuedByOn: ...
  ...
  $$ro: {
    ...
    issuedBy: { ... },
    $changeIssuedByOn: {
      ...
      parameters: {
        issuedBy: {
          ...
          choices: [ "Visa", "Mastercard", "Amex" ]
        },
        date: { ... }
      },
      prompt: true
    }
  }
}

If 'issuedBy' parameter is a reference, then the choices are a list of {$$href:...,$$title:...} maps (same as for properties, iteration #19)

If there are defaults (iteration #23) then these will also become available.
</pre>

      </section>

      <section>
        <h1>
<a name="action-param-auto-complete" class="anchor" href="#action-param-auto-complete"><span class="octicon octicon-link"></span></a>Action param auto-complete</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                select action parameter from list of available choices, using a 'typeahead' parameter to filter
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>

          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


Similarly to properties, Spiro sets up a watch on an "argument" property under $$ro and populates the choices.  The client can set up its own watch on the resultant choices.

Suppose 'changeIssuedByOn(issuedBy, date)' is an action.

given:
var card = CreditCard.get({num: "1234-5678-9012-3456"})

returning:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  issuedBy: "Amex",
  $changeIssuedByOn: ...
  ...
  $$ro: {
    ...
    issuedBy: { ... },
    $changeIssuedByOn: {
      ...
      parameters: {
        issuedBy: {
          ...
          argument: null,
          choices: null
        },
        date: { ... }
      },
      prompt: false
    }
  }
}

as for previous iterations, "choices" is present to indicate that choices may be computed if a prompt is requested.

when
card.$$ro.$changeIssuedByOn.issuedBy.argument = "s"

then:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  issuedBy: "Amex",
  $changeIssuedByOn: ...
  ...
  $$ro: {
    ...
  $$ro: {
    ...
    issuedBy: { ... },
    $changeIssuedByOn: {
      ...
      parameters: {
        issuedBy: {
          ...
          argument: "s",
          choices: [ "Visa", "Mastercard" ]
        },
        date: { ... }
      },
      prompt: true
    }
  }
}

Setting the value for any argument will implicitly set "prompt" to true, and so will retrieve defaults/choices for this parameter (filtered based on provided argument) and any other parameters of the action.
</pre>

      </section>

      <section>
        <h1>
<a name="action-param-choices-conditional" class="anchor" href="#action-param-choices-conditional"><span class="octicon octicon-link"></span></a>Action param choices (conditional)</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                The choices for one parameter depend upon those of another.
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>


          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>
The choices for one parameter depend upon those of another.

Suppose that recategorizing a credit card is accomplished through a recategorize(category, subcategory) action:

given:
var card = CreditCard.get({num: "1234-5678-9012-3456"})

returning:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  category: "CAT-1"
  subcategory: "SUBCAT-1-c",
  ...
  $recategorize: ...
  ...
  $$ro: {
    ...
    $recategorize: {
      parameters: {
        category: {
          ...
          argument: null,
          choices: null
        }
        subcategory: {
          ...
          argument: null,
          choices: null
        }
      },
      prompt: false
    }
  }
}

In the above the list of choices for the subcategory parameter is empty because the argument for "category" is still null

when:
card.$$ro.$recategorize.parameters.category.argument = "CAT-2"

then:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  category: "CAT-1"
  subcategory: "SUBCAT-1-c",
  ...
  $recategorize: ...
  ...
  $$ro: {
    ...
    $recategorize: {
      parameters: {
        category: {
          ...
          argument: "CAT-2",
          choices: [ "CAT-1", "CAT-2", "CAT-3" ]
        }
        subcategory: {
          ...
          argument: null,
          choices: [ "SUBCAT-2-a", "SUBCAT-2-b", "SUBCAT-2-c" ] 
        }
      },
      prompt: true
    }
  }
}

implicitly sets up the prompt, computes the choices for category parameter, and computes the subcategory choices based on the category argument 
</pre>

      </section>

      <section>
        <h1>
<a name="action-param-auto-complete-conditional" class="anchor" href="#action-param-auto-complete-conditional"><span class="octicon octicon-link"></span></a>Action param auto-complete (conditional)</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Select action parameter from list of available choices which are dependent on other parameters, using a 'typeahead' parameter to filter
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>


          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>

Suppose that recategorizing a credit card is accomplished through a recategorize(category, subcategory) action, but where the choices for subcategory is filtered based on a "typeahead" value.

given:
var card = CreditCard.get({num: "1234-5678-9012-3456"})

and:
card.$$ro.$recategorize.parameters.category.argument="CAT-2"

returning:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  category: "CAT-1"
  subcategory: "SUBCAT-1-c",
  ...
  $recategorize: ...
  ...
  $$ro: {
    ...
    $recategorize: {
      parameters: {
        category: {
          ...
          argument: "CAT-2",
          choices: [ "CAT-1", "CAT-2", "CAT-3" ]
        }
        subcategory: {
          ...
          argument: null,
          choices: [ ] 
        }
      },
      prompt: true
    }
  }
}

In the above the prompt has been requested implicitly because an argument for category paramter was set, and this also caused the list of choices for the category parameter to be computed.  However, the subcategory argument is still null and so the choices for the subcategory is empty also.

when:
card.$$ro.$recategorize.parameters.subcategory.argument = "b"

then:
{
  num: "1234-5678-9012-3456",
  name: "Mike Smith",
  category: "CAT-1"
  subcategory: "SUBCAT-1-c",
  ...
  $recategorize: ...
  ...
  $$ro: {
    ...
    $recategorize: {
      parameters: {
        category: {
          ...
          argument: "CAT-2",
          choices: [ "CAT-1", "CAT-2", "CAT-3" ]
        }
        subcategory: {
          ...
          argument: "b",
          choices: [ "SUBCAT-2-bar", "SUBCAT-2-baz", "SUBCAT-2-fab", "SUBCAT-2-pbl" ] 
        }
      }
    }
  }
}

entering an argument for subcategory parameter now populates the choices for those matching the category and filtered by the subcategory search arg.
</pre>

      </section>

      <section>
        <h1>
<a name="delete" class="anchor" href="#delete"><span class="octicon octicon-link"></span></a>delete()</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Allow objects to be deleted using an API similar to that surfaced by <code>$resource</code>.
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>


          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


<code>$resource</code> provides delete() / remove() as "standard" actions; these perform an HTTP DELETE against the URL.  <code>$spiroResource</code> provide something very similar.

given
var cc = CreditCard.get({instanceId: 123})

when:
cc.$delete()

then:
??? what are the post-conditions for $<code>$resource</code> ??
</pre>

      </section>

      <section>
        <h1>
<a name="save" class="anchor" href="#save"><span class="octicon octicon-link"></span></a>save()</h1>

          <div class="use-case">
              <h3>Use case</h3>
              <p>
                Allow objects to be created using an API similar to that surfaced by <code>$resource</code>.
              </p>
          </div>

          <p>
              TODO - general discussion
          </p>

          <h3>Given:</h3>
<pre>
</pre>
          <h3>When:</h3>
<pre>
</pre>
          <h3>Then:</h3>
<pre>
</pre>

          <h3>Discussion</h3>
          <p>
              TODO
          </p>
<pre>
</pre>


          <h3>See also</h3>
          <ul>
              <li><a href="#TODO">TODO</a></li>
          </ul>

          <h3>Implementation Notes</h3>
          <p>
              TODO
          </p>

<pre>


<code>$resource</code> provides save() as a standard action; this performs an HTTP POST against the URL.  <code>$spiroResource</code> provides something very similar.

given:
var newCard = new CreditCard({number:'1234-5678-9090-1212', name: "John Doe"});

when:
newCard.$save();

then:
{
  num: "1234-5678-9090-1212",
  name: "John Doe",
  ...
}

and HTTP status code 201
</pre>

      </section>
      
      <section>
        <h1>
<a name="further-ideas" class="anchor" href="#further-ideas"><span class="octicon octicon-link"></span></a>Further ideas...</h1>

<pre>
* warnings
* HTTP status codes
* error handling
* support for optimistic locking
* alternative syntax for update properties:  write to $$ro.property.proposed
* support for SignalR/web sockets automatic updates
</pre>

      </section>

      <section>
          <h1>
              <a name="ro-1-1" class="anchor" href="#ro-1-1"><span class="octicon octicon-link"></span></a>Restful Objects v1.1</h1>

<pre>
      APPENDIX: the RO 1.1 resources

      key:
      XXX* indicates supports validation (via ?x-ro-validate-only optional param)



      "Services"
      /services
      GET


      "Objects Of Type"
      /objects/{domainType}
      POST*



      "Object" or "Service"
      /objects/{domainType}/{instanceId}
      /services/{serviceId}
      GET


      "Object Property"
      /objects/{domainType}/{instanceId}/properties/{property}
      GET
      PUT*
      DELETE*


      "Object Property Prompt"
      /objects/{domainType}/{instanceId}/properties/{property}/prompt
      GET


      "Object Collection"
      /objects/{domainType}/{instanceId}/collections/{collection}
      GET
      POST* or PUT*


      "Object Action" or "Service Action"
      /objects/{domainType}/{instanceId}/actions/{actionId}
      services/{serviceId}/actions/{actionId}
      GET


      "Object Action Parameter Prompt"
      /objects/{domainType}/{instanceId}/actions/{actionId}/params/{param}/prompt
      GET


      "Object Action Invoke" or "Service Action Invoke"
      /objects/{domainType}/{instanceId}/actions/{actionId}/invoke
      /services/{serviceId}/actions/{actionId}/invoke
      GET*, PUT*, POST*
</pre>

      </section>

      <footer>
      <!--
        <p>Project maintained by <a href="https://github.com/SpiroLibraries">SpiroLibraries</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      -->
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>